<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "a45c318dc6ebc2604f35b8b829f93af2",
  "translation_date": "2025-05-19T09:54:38+00:00",
  "source_file": "04-prompt-engineering-fundamentals/README.md",
  "language_code": "hi"
}
-->
# प्रॉम्प्ट इंजीनियरिंग की मूल बातें

## परिचय
यह मॉड्यूल जनरेटिव AI मॉडल में प्रभावी प्रॉम्प्ट बनाने के लिए आवश्यक अवधारणाओं और तकनीकों को कवर करता है। जिस तरह से आप अपने प्रॉम्प्ट को LLM को लिखते हैं, वह भी महत्वपूर्ण है। एक सावधानीपूर्वक तैयार किया गया प्रॉम्प्ट बेहतर गुणवत्ता की प्रतिक्रिया प्राप्त कर सकता है। लेकिन _प्रॉम्प्ट_ और _प्रॉम्प्ट इंजीनियरिंग_ जैसे शब्द वास्तव में क्या मतलब रखते हैं? और मैं LLM को भेजे जाने वाले प्रॉम्प्ट _इनपुट_ को कैसे सुधार सकता हूं? ये वे प्रश्न हैं जिनका हम इस अध्याय और अगले में उत्तर देने का प्रयास करेंगे।

_जनरेटिव AI_ उपयोगकर्ता अनुरोधों के जवाब में नया कंटेंट (जैसे, टेक्स्ट, इमेज, ऑडियो, कोड आदि) बनाने में सक्षम है। यह प्राकृतिक भाषा और कोड का उपयोग करने के लिए प्रशिक्षित OpenAI के GPT ("जनरेटिव प्री-ट्रेंड ट्रांसफॉर्मर") श्रृंखला जैसे _बड़े भाषा मॉडल_ का उपयोग करके इसे प्राप्त करता है।

उपयोगकर्ता अब तकनीकी विशेषज्ञता या प्रशिक्षण की आवश्यकता के बिना चैट जैसे परिचित पैटर्न का उपयोग करके इन मॉडलों के साथ बातचीत कर सकते हैं। मॉडल _प्रॉम्प्ट-आधारित_ हैं - उपयोगकर्ता एक टेक्स्ट इनपुट (प्रॉम्प्ट) भेजते हैं और AI प्रतिक्रिया (समापन) प्राप्त करते हैं। वे तब "AI के साथ चैट" कर सकते हैं, मल्टी-टर्न वार्तालापों में अपने प्रॉम्प्ट को परिष्कृत कर सकते हैं जब तक कि प्रतिक्रिया उनकी अपेक्षाओं से मेल नहीं खाती।

"प्रॉम्प्ट" अब जनरेटिव AI ऐप्स के लिए प्राथमिक _प्रोग्रामिंग इंटरफेस_ बन जाते हैं, जो मॉडलों को क्या करना है और लौटाई गई प्रतिक्रियाओं की गुणवत्ता को प्रभावित करते हैं। "प्रॉम्प्ट इंजीनियरिंग" एक तेजी से बढ़ता हुआ अध्ययन का क्षेत्र है जो _डिजाइन और अनुकूलन_ पर केंद्रित है ताकि लगातार और गुणवत्ता वाली प्रतिक्रियाएं बड़े पैमाने पर प्राप्त की जा सकें।

## सीखने के लक्ष्य

इस पाठ में, हम सीखते हैं कि प्रॉम्प्ट इंजीनियरिंग क्या है, यह क्यों महत्वपूर्ण है, और हम दिए गए मॉडल और एप्लिकेशन उद्देश्य के लिए अधिक प्रभावी प्रॉम्प्ट कैसे बना सकते हैं। हम प्रॉम्प्ट इंजीनियरिंग के मूल अवधारणाओं और सर्वोत्तम प्रथाओं को समझेंगे - और एक इंटरैक्टिव जुपिटर नोटबुक "सैंडबॉक्स" वातावरण के बारे में जानेंगे जहां हम वास्तविक उदाहरणों पर इन अवधारणाओं को लागू होते देख सकते हैं।

इस पाठ के अंत तक, हम सक्षम होंगे:

1. प्रॉम्प्ट इंजीनियरिंग क्या है और यह क्यों महत्वपूर्ण है, समझाएं।
2. प्रॉम्प्ट के घटकों का वर्णन करें और उनका उपयोग कैसे किया जाता है।
3. प्रॉम्प्ट इंजीनियरिंग के सर्वोत्तम प्रथाओं और तकनीकों को सीखें।
4. ओपनएआई एंडपॉइंट का उपयोग करके वास्तविक उदाहरणों पर सीखी गई तकनीकों को लागू करें।

## प्रमुख शब्द

प्रॉम्प्ट इंजीनियरिंग: AI मॉडल को वांछित आउटपुट उत्पन्न करने के लिए मार्गदर्शन करने के लिए इनपुट्स को डिजाइन और परिष्कृत करने का अभ्यास।
टोकनाइजेशन: टेक्स्ट को छोटे इकाइयों में बदलने की प्रक्रिया, जिन्हें मॉडल समझ और प्रक्रिया कर सकता है।
इंस्ट्रक्शन-ट्यूनड LLMs: बड़े भाषा मॉडल (LLMs) जिन्हें उनकी प्रतिक्रिया की सटीकता और प्रासंगिकता में सुधार करने के लिए विशेष निर्देशों के साथ फाइन-ट्यून किया गया है।

## सीखने का सैंडबॉक्स

प्रॉम्प्ट इंजीनियरिंग वर्तमान में विज्ञान से अधिक कला है। इसे सुधारने के लिए हमारी अंतर्दृष्टि का सबसे अच्छा तरीका _अधिक अभ्यास_ करना है और अनुशंसित तकनीकों और मॉडल-विशिष्ट अनुकूलन के साथ एप्लिकेशन डोमेन विशेषज्ञता को मिलाकर एक परीक्षण-और-त्रुटि दृष्टिकोण अपनाना है।

इस पाठ के साथ आने वाला जुपिटर नोटबुक एक _सैंडबॉक्स_ वातावरण प्रदान करता है जहां आप जो सीखते हैं उसे आजमा सकते हैं - जैसा कि आप जाते हैं या अंत में कोड चुनौती के हिस्से के रूप में। अभ्यास करने के लिए, आपको आवश्यकता होगी:

1. **एक Azure OpenAI API कुंजी** - एक तैनात LLM के लिए सेवा एंडपॉइंट।
2. **एक पायथन रनटाइम** - जिसमें नोटबुक को निष्पादित किया जा सकता है।
3. **स्थानीय एनव वेरिएबल्स** - _[सेटअप](./../00-course-setup/SETUP.md?WT.mc_id=academic-105485-koreyst) चरणों को अभी पूरा करें ताकि तैयार हो सकें_।

नोटबुक _स्टार्टर_ अभ्यासों के साथ आता है - लेकिन आपको प्रोत्साहित किया जाता है कि आप अधिक उदाहरणों या विचारों को आजमाने के लिए अपने स्वयं के _मार्कडाउन_ (वर्णन) और _कोड_ (प्रॉम्प्ट अनुरोध) अनुभाग जोड़ें - और प्रॉम्प्ट डिज़ाइन के लिए अपनी अंतर्दृष्टि बनाएं।

## चित्रित गाइड

क्या आप इस पाठ में शामिल विषयों की पूरी तस्वीर प्राप्त करना चाहते हैं इससे पहले कि आप इसमें डूब जाएं? इस चित्रित गाइड को देखें, जो आपको उन मुख्य विषयों का एहसास देता है जो इसमें शामिल हैं और उन प्रमुख निष्कर्षों के बारे में सोचने के लिए आपको प्रत्येक में विचार करने के लिए प्रेरित करता है। पाठ रोडमैप आपको मुख्य अवधारणाओं और चुनौतियों को समझने से लेकर उन्हें प्रासंगिक प्रॉम्प्ट इंजीनियरिंग तकनीकों और सर्वोत्तम प्रथाओं के साथ संबोधित करने तक ले जाता है। ध्यान दें कि इस गाइड में "उन्नत तकनीकें" अनुभाग इस पाठ्यक्रम के _अगले_ अध्याय में शामिल सामग्री को संदर्भित करता है।

## हमारा स्टार्टअप

अब, आइए बात करें कि _यह विषय_ हमारे स्टार्टअप मिशन से कैसे संबंधित है [शिक्षा में AI नवाचार लाने के लिए](https://educationblog.microsoft.com/2023/06/collaborating-to-bring-ai-innovation-to-education?WT.mc_id=academic-105485-koreyst)। हम _व्यक्तिगत सीखने_ के AI-संचालित अनुप्रयोगों को बनाना चाहते हैं - इसलिए आइए सोचें कि हमारे एप्लिकेशन के विभिन्न उपयोगकर्ता प्रॉम्प्ट को कैसे "डिज़ाइन" कर सकते हैं:

- **प्रशासक** AI से _पाठ्यक्रम डेटा का विश्लेषण करके कवरेज में अंतराल की पहचान_ करने के लिए कह सकते हैं। AI परिणामों को संक्षेप में प्रस्तुत कर सकता है या उन्हें कोड के साथ दृश्य बना सकता है।
- **शिक्षक** AI से _लक्षित दर्शकों और विषय के लिए एक पाठ योजना बनाने_ के लिए कह सकते हैं। AI निर्दिष्ट प्रारूप में व्यक्तिगत योजना बना सकता है।
- **छात्र** AI से _कठिन विषय में उन्हें ट्यूटर करने_ के लिए कह सकते हैं। AI अब छात्रों को उनके स्तर के अनुसार पाठ, संकेत और उदाहरण प्रदान करके मार्गदर्शन कर सकता है।

यह तो सिर्फ हिमशैल का सिरा है। [शिक्षा के लिए प्रॉम्प्ट्स](https://github.com/microsoft/prompts-for-edu/tree/main?WT.mc_id=academic-105485-koreyst) - एक ओपन-सोर्स प्रॉम्प्ट्स लाइब्रेरी जो शिक्षा विशेषज्ञों द्वारा क्यूरेट की गई है - की जांच करें ताकि संभावनाओं का व्यापक रूप से अंदाजा लगाया जा सके! _सैंडबॉक्स में उन प्रॉम्प्ट्स में से कुछ को चलाने की कोशिश करें या देखें कि ओपनएआई प्लेग्राउंड में क्या होता है!_

## प्रॉम्प्ट इंजीनियरिंग क्या है?

हमने इस पाठ की शुरुआत **प्रॉम्प्ट इंजीनियरिंग** को _डिज़ाइन और अनुकूलन_ प्रक्रिया के रूप में परिभाषित करते हुए की है, जो एक दिए गए एप्लिकेशन उद्देश्य और मॉडल के लिए लगातार और गुणवत्ता प्रतिक्रियाएं (समापन) प्रदान करने के लिए टेक्स्ट इनपुट (प्रॉम्प्ट्स) को परिभाषित करता है। हम इसे एक 2-चरण प्रक्रिया के रूप में सोच सकते हैं:

- एक दिए गए मॉडल और उद्देश्य के लिए प्रारंभिक प्रॉम्प्ट को _डिज़ाइन_ करना
- प्रतिक्रिया की गुणवत्ता में सुधार करने के लिए प्रॉम्प्ट को _परिष्कृत_ करना

यह आवश्यक रूप से एक परीक्षण-और-त्रुटि प्रक्रिया है जिसमें इष्टतम परिणाम प्राप्त करने के लिए उपयोगकर्ता अंतर्दृष्टि और प्रयास की आवश्यकता होती है। तो यह क्यों महत्वपूर्ण है? इस प्रश्न का उत्तर देने के लिए, हमें पहले तीन अवधारणाओं को समझना होगा:

- _टोकनाइजेशन_ = मॉडल प्रॉम्प्ट को कैसे "देखता" है
- _बेस LLMs_ = फाउंडेशन मॉडल प्रॉम्प्ट को कैसे "प्रक्रिया" करता है
- _इंस्ट्रक्शन-ट्यूनड LLMs_ = मॉडल अब "कार्य" कैसे देख सकता है

### टोकनाइजेशन

एक LLM प्रॉम्प्ट को _टोकन के अनुक्रम_ के रूप में देखता है जहां विभिन्न मॉडल (या मॉडल के संस्करण) एक ही प्रॉम्प्ट को विभिन्न तरीकों से टोकनाइज कर सकते हैं। चूंकि LLMs टोकन पर प्रशिक्षित होते हैं (और कच्चे टेक्स्ट पर नहीं), इसलिए जिस तरह से प्रॉम्प्ट्स को टोकनाइज किया जाता है, उसका उत्पन्न प्रतिक्रिया की गुणवत्ता पर सीधा प्रभाव पड़ता है।

टोकनाइजेशन कैसे काम करता है, इसकी अंतर्दृष्टि प्राप्त करने के लिए [OpenAI Tokenizer](https://platform.openai.com/tokenizer?WT.mc_id=academic-105485-koreyst) जैसे टूल आज़माएं। अपने प्रॉम्प्ट को कॉपी करें - और देखें कि वह टोकन में कैसे बदलता है, ध्यान दें कि व्हाइटस्पेस कैरेक्टर्स और विराम चिह्नों को कैसे संभाला जाता है। ध्यान दें कि यह उदाहरण एक पुराने LLM (GPT-3) को दिखाता है - इसलिए इसे एक नए मॉडल के साथ आजमाने से एक अलग परिणाम उत्पन्न हो सकता है।

### अवधारणा: फाउंडेशन मॉडल्स

एक बार प्रॉम्प्ट टोकनाइज हो जाने के बाद, ["बेस LLM"](https://blog.gopenai.com/an-introduction-to-base-and-instruction-tuned-large-language-models-8de102c785a6?WT.mc_id=academic-105485-koreyst) (या फाउंडेशन मॉडल) का प्राथमिक कार्य उस अनुक्रम में टोकन की भविष्यवाणी करना होता है। चूंकि LLMs को विशाल टेक्स्ट डेटासेट पर प्रशिक्षित किया जाता है, उनके पास टोकन के बीच सांख्यिकीय संबंधों की अच्छी समझ होती है और वे कुछ आत्मविश्वास के साथ उस भविष्यवाणी को कर सकते हैं। ध्यान दें कि वे प्रॉम्प्ट या टोकन में शब्दों के _अर्थ_ को नहीं समझते हैं; वे केवल एक पैटर्न देखते हैं जिसे वे अपनी अगली भविष्यवाणी के साथ "पूरा" कर सकते हैं। वे तब तक अनुक्रम की भविष्यवाणी जारी रख सकते हैं जब तक कि उपयोगकर्ता हस्तक्षेप या कुछ पूर्व-स्थापित स्थिति द्वारा समाप्त नहीं किया जाता।

क्या आप देखना चाहते हैं कि प्रॉम्प्ट-आधारित समापन कैसे काम करता है? डिफ़ॉल्ट सेटिंग्स के साथ Azure OpenAI Studio [_Chat Playground_](https://oai.azure.com/playground?WT.mc_id=academic-105485-koreyst) में ऊपर दिए गए प्रॉम्प्ट को दर्ज करें। सिस्टम को प्रॉम्प्ट्स को जानकारी के अनुरोध के रूप में मानने के लिए कॉन्फ़िगर किया गया है - इसलिए आपको इस संदर्भ को संतुष्ट करने वाला एक समापन दिखाई देना चाहिए।

लेकिन अगर उपयोगकर्ता कुछ विशिष्ट देखना चाहता था जो कुछ मानदंडों या कार्य उद्देश्य को पूरा करता था तो क्या होगा? यह वह जगह है जहां _इंस्ट्रक्शन-ट्यूनड_ LLMs तस्वीर में आते हैं।

### अवधारणा: इंस्ट्रक्शन-ट्यूनड LLMs

एक [इंस्ट्रक्शन-ट्यूनड LLM](https://blog.gopenai.com/an-introduction-to-base-and-instruction-tuned-large-language-models-8de102c785a6?WT.mc_id=academic-105485-koreyst) फाउंडेशन मॉडल से शुरू होता है और इसे उदाहरणों या इनपुट/आउटपुट जोड़े (जैसे, मल्टी-टर्न "संदेश") के साथ फाइन-ट्यून करता है जो स्पष्ट निर्देशों को शामिल कर सकता है - और AI का प्रयास उस निर्देश का पालन करने के लिए प्रतिक्रिया करता है।

यह मानव फीडबैक के साथ सुदृढीकरण सीखने (RLHF) जैसी तकनीकों का उपयोग करता है जो मॉडल को _निर्देशों का पालन_ करने और _फीडबैक से सीखने_ के लिए प्रशिक्षित कर सकता है ताकि यह प्रतिक्रियाएं उत्पन्न करे जो व्यावहारिक अनुप्रयोगों के लिए बेहतर अनुकूल हों और उपयोगकर्ता उद्देश्यों के लिए अधिक प्रासंगिक हों।

आइए इसे आजमाएं - ऊपर दिए गए प्रॉम्प्ट पर पुनर्विचार करें, लेकिन अब _सिस्टम संदेश_ को निम्नलिखित निर्देश प्रदान करने के लिए संदर्भ के रूप में बदलें:

> _दूसरी कक्षा के छात्र के लिए प्रदान की गई सामग्री का सारांश दें। परिणाम को 3-5 बुलेट पॉइंट्स के साथ एक पैराग्राफ तक सीमित रखें।_

देखें कि परिणाम अब वांछित लक्ष्य और प्रारूप को कैसे दर्शाता है? एक शिक्षक अब इस प्रतिक्रिया का उपयोग अपनी कक्षा के लिए स्लाइड्स में सीधे कर सकता है।

## प्रॉम्प्ट इंजीनियरिंग की आवश्यकता क्यों है?

अब जब हम जानते हैं कि LLMs द्वारा प्रॉम्प्ट्स कैसे संसाधित किए जाते हैं, तो आइए बात करें कि _क्यों_ हमें प्रॉम्प्ट इंजीनियरिंग की आवश्यकता है। इसका उत्तर इस तथ्य में निहित है कि वर्तमान LLMs कई चुनौतियाँ पेश करते हैं जो _विश्वसनीय और सुसंगत समापन_ प्राप्त करना अधिक चुनौतीपूर्ण बनाते हैं बिना प्रॉम्प्ट निर्माण और अनुकूलन में प्रयास किए। उदाहरण के लिए:

1. **मॉडल प्रतिक्रियाएं अनियमित होती हैं।** _वही प्रॉम्प्ट_ संभवतः विभिन्न मॉडलों या मॉडल संस्करणों के साथ विभिन्न प्रतिक्रियाएं उत्पन्न करेगा। और यह _उसी मॉडल_ के साथ अलग-अलग समय पर भी अलग-अलग परिणाम उत्पन्न कर सकता है। _प्रॉम्प्ट इंजीनियरिंग तकनीकें हमें बेहतर सुरक्षा प्रदान करके इन भिन्नताओं को कम करने में मदद कर सकती हैं_।

1. **मॉडल प्रतिक्रियाएं बना सकते हैं।** मॉडल _बड़े लेकिन सीमित_ डेटासेट के साथ पूर्व-प्रशिक्षित होते हैं, जिसका अर्थ है कि वे उस प्रशिक्षण सीमा के बाहर की अवधारणाओं के बारे में ज्ञान की कमी रखते हैं। नतीजतन, वे ऐसे समापन उत्पन्न कर सकते हैं जो गलत, काल्पनिक, या ज्ञात तथ्यों के सीधे विरोधाभासी हों। _प्रॉम्प्ट इंजीनियरिंग तकनीकें उपयोगकर्ताओं को ऐसी गढ़नाओं की पहचान करने और उन्हें कम करने में मदद करती हैं, उदाहरण के लिए, AI से उद्धरण या तर्क पूछकर_।

1. **मॉडल क्षमताएं भिन्न होंगी।** नए मॉडल या मॉडल पीढ़ियाँ समृद्ध क्षमताएँ होंगी लेकिन लागत और जटिलता में अद्वितीय विचित्रताएँ और समझौते भी लाएँगी। _प्रॉम्प्ट इंजीनियरिंग हमें सर्वोत्तम प्रथाओं और कार्यप्रवाहों को विकसित करने में मदद कर सकती है जो मतभेदों को दूर करती हैं और स्केलेबल, सहज तरीकों से मॉडल-विशिष्ट आवश्यकताओं के लिए अनुकूल होती हैं_।

आइए इसे OpenAI या Azure OpenAI Playground में क्रिया में देखें:

- विभिन्न LLM तैनातियों के साथ एक ही प्रॉम्प्ट का उपयोग करें (जैसे, OpenAI, Azure OpenAI, Hugging Face) - क्या आपने भिन्नताओं को देखा?
- _उसी_ LLM तैनाती के साथ बार-बार एक ही प्रॉम्प्ट का उपयोग करें (जैसे, Azure OpenAI Playground) - ये भिन्नताएँ कैसे भिन्न थीं?

### गढ़नाओं का उदाहरण

इस पाठ्यक्रम में, हम **"गढ़न"** शब्द का उपयोग उस घटना को संदर्भित करने के लिए करते हैं जहां LLMs कभी-कभी अपने प्रशिक्षण या अन्य बाधाओं के कारण तथ्यात्मक रूप से गलत जानकारी उत्पन्न करते हैं। आपने इसे लोकप्रिय लेखों या शोध पत्रों में _"भ्रम"_ के रूप में संदर्भित होते हुए भी सुना होगा। हालांकि, हम दृढ़ता से अनुशंसा करते हैं कि हम व्यवहार को मानव-समान गुण को मशीन-चालित परिणाम के रूप में मान्यता देते हुए गलती से मानवीकरण न करें ताकि हम _"गढ़न"_ को शब्द के रूप में उपयोग करें। यह शब्दावली के दृष्टिकोण से [जिम्मेदार AI दिशानिर्देशों](https://www.microsoft.com/ai/responsible-ai?WT.mc_id=academic-105485-koreyst) को भी मजबूत करता है, उन शब्दों को हटाकर जो कुछ संदर्भों में अपमानजनक या गैर-समावेशी भी माने जा सकते हैं।

गढ़नाएँ कैसे काम करती हैं, इसका अंदाजा लगाना चाहते हैं? एक प्रॉम्प्ट सोचें जो AI को एक गैर-मौजूद विषय के लिए सामग्री उत्पन्न करने का निर्देश देता है (सुनिश्चित करने के लिए कि यह प्रशिक्षण डेटासेट में नहीं पाया गया है)। उदाहरण के लिए - मैंने इस प्रॉम्प्ट को आजमाया:

> **प्रॉम्प्ट:** 2076 के मार्टियन युद्ध पर एक पाठ योजना बनाएं।

एक वेब खोज ने मुझे दिखाया कि मार्टियन युद्धों पर काल्पनिक खाते (जैसे, टेलीविजन श्रृंखला या पुस्तकें) थीं - लेकिन 2076 में कोई नहीं। सामान्य ज्ञान भी हमें बताता है कि 2076 _भविष्य में_ है और इसलिए, इसे वास्तविक
अंततः, टेम्पलेट्स का असली मूल्य वर्टिकल एप्लिकेशन डोमेन के लिए _प्रॉम्प्ट लाइब्रेरी_ बनाने और प्रकाशित करने की क्षमता में निहित है - जहाँ प्रॉम्प्ट टेम्पलेट अब एप्लिकेशन-विशिष्ट संदर्भ या उदाहरणों को प्रतिबिंबित करने के लिए _अनुकूलित_ है जो लक्षित उपयोगकर्ता दर्शकों के लिए प्रतिक्रियाओं को अधिक प्रासंगिक और सटीक बनाता है। [Prompts For Edu](https://github.com/microsoft/prompts-for-edu?WT.mc_id=academic-105485-koreyst) रिपॉजिटरी इस दृष्टिकोण का एक शानदार उदाहरण है, जो शिक्षा डोमेन के लिए प्रॉम्प्ट्स की एक लाइब्रेरी को क्यूरेट करता है, जिसमें पाठ योजना, पाठ्यक्रम डिजाइन, छात्र ट्यूशन आदि जैसे प्रमुख उद्देश्यों पर जोर दिया गया है।

## सहायक सामग्री

यदि हम प्रॉम्प्ट निर्माण को एक निर्देश (कार्य) और एक लक्ष्य (प्राथमिक सामग्री) के रूप में सोचें, तो _माध्यमिक सामग्री_ एक अतिरिक्त संदर्भ की तरह है जिसे हम **किसी न किसी तरीके से आउटपुट को प्रभावित करने के लिए** प्रदान करते हैं। यह ट्यूनिंग पैरामीटर, फॉर्मेटिंग निर्देश, विषय वर्गीकरण आदि हो सकता है जो मॉडल को अपनी प्रतिक्रिया को वांछित उपयोगकर्ता उद्देश्यों या अपेक्षाओं के अनुकूल बनाने में मदद कर सकता है।

उदाहरण के लिए: एक पाठ्यक्रम कैटलॉग के साथ जिसमें पाठ्यक्रम में उपलब्ध सभी पाठ्यक्रमों पर व्यापक मेटाडेटा (नाम, विवरण, स्तर, मेटाडेटा टैग, प्रशिक्षक आदि) हो:

- हम एक निर्देश को परिभाषित कर सकते हैं "फॉल 2023 के लिए पाठ्यक्रम कैटलॉग का सारांश दें"
- हम वांछित आउटपुट के कुछ उदाहरण प्रदान करने के लिए प्राथमिक सामग्री का उपयोग कर सकते हैं
- हम माध्यमिक सामग्री का उपयोग कर सकते हैं ताकि शीर्ष 5 "टैग्स" की पहचान कर सकें जिनमें रुचि है।

अब, मॉडल कुछ उदाहरणों द्वारा दिखाए गए फॉर्मेट में सारांश प्रदान कर सकता है - लेकिन अगर किसी परिणाम में कई टैग हैं, तो यह माध्यमिक सामग्री में पहचाने गए 5 टैग्स को प्राथमिकता दे सकता है।

---

## प्रॉम्प्टिंग सर्वोत्तम प्रथाएं

अब जब हम जानते हैं कि प्रॉम्प्ट्स को कैसे _निर्मित_ किया जा सकता है, हम यह सोच सकते हैं कि उन्हें सर्वोत्तम प्रथाओं को प्रतिबिंबित करने के लिए कैसे _डिजाइन_ किया जा सकता है। हम इसे दो भागों में सोच सकते हैं - सही _सोच_ और सही _तकनीकों_ का उपयोग करना।

### प्रॉम्प्ट इंजीनियरिंग मानसिकता

प्रॉम्प्ट इंजीनियरिंग एक परीक्षण और त्रुटि प्रक्रिया है, इसलिए तीन व्यापक मार्गदर्शक कारकों को ध्यान में रखें:

1. **डोमेन समझ महत्वपूर्ण है।** प्रतिक्रिया की सटीकता और प्रासंगिकता उस _डोमेन_ का कार्य है जिसमें वह एप्लिकेशन या उपयोगकर्ता काम करता है। अपनी अंतर्ज्ञान और डोमेन विशेषज्ञता का उपयोग करके **तकनीकों को अनुकूलित करें**। उदाहरण के लिए, अपने सिस्टम प्रॉम्प्ट्स में _डोमेन-विशिष्ट व्यक्तित्व_ परिभाषित करें, या अपने उपयोगकर्ता प्रॉम्प्ट्स में _डोमेन-विशिष्ट टेम्पलेट्स_ का उपयोग करें। माध्यमिक सामग्री प्रदान करें जो डोमेन-विशिष्ट संदर्भों को प्रतिबिंबित करती है, या _डोमेन-विशिष्ट संकेत और उदाहरण_ का उपयोग करें ताकि मॉडल को परिचित उपयोग पैटर्न की ओर मार्गदर्शन किया जा सके।

2. **मॉडल समझ महत्वपूर्ण है।** हम जानते हैं कि मॉडल स्वाभाविक रूप से स्टोकेस्टिक होते हैं। लेकिन मॉडल कार्यान्वयन उस प्रशिक्षण डेटासेट के संदर्भ में भी भिन्न हो सकते हैं जिसका वे उपयोग करते हैं (पूर्व-प्रशिक्षित ज्ञान), जो क्षमताएं वे प्रदान करते हैं (जैसे, एपीआई या एसडीके के माध्यम से) और जिस प्रकार की सामग्री के लिए वे अनुकूलित होते हैं (जैसे, कोड बनाम छवियां बनाम पाठ)। जिस मॉडल का आप उपयोग कर रहे हैं उसकी ताकत और सीमाओं को समझें, और उस ज्ञान का उपयोग _कार्य प्राथमिकता_ देने या _अनुकूलित टेम्पलेट्स_ बनाने के लिए करें जो मॉडल की क्षमताओं के लिए अनुकूलित हों।

3. **पुनरावृत्ति और सत्यापन महत्वपूर्ण हैं।** मॉडल तेजी से विकसित हो रहे हैं, और प्रॉम्प्ट इंजीनियरिंग के लिए तकनीकें भी। एक डोमेन विशेषज्ञ के रूप में, आपके पास अपने विशिष्ट एप्लिकेशन के लिए अन्य संदर्भ या मानदंड हो सकते हैं, जो व्यापक समुदाय पर लागू नहीं हो सकते। प्रॉम्प्ट इंजीनियरिंग टूल्स और तकनीकों का उपयोग करें ताकि प्रॉम्प्ट निर्माण को "जंप स्टार्ट" किया जा सके, फिर अपनी अंतर्ज्ञान और डोमेन विशेषज्ञता का उपयोग करके परिणामों को पुनरावृत्त और सत्यापित करें। अपनी अंतर्दृष्टि को रिकॉर्ड करें और एक **ज्ञान आधार** (जैसे, प्रॉम्प्ट लाइब्रेरीज़) बनाएं जिसे दूसरों द्वारा भविष्य में तेजी से पुनरावृत्तियों के लिए एक नई आधार रेखा के रूप में उपयोग किया जा सके।

## सर्वोत्तम प्रथाएं

अब आइए सामान्य सर्वोत्तम प्रथाओं को देखें जो [OpenAI](https://help.openai.com/en/articles/6654000-best-practices-for-prompt-engineering-with-openai-api?WT.mc_id=academic-105485-koreyst) और [Azure OpenAI](https://learn.microsoft.com/azure/ai-services/openai/concepts/prompt-engineering#best-practices?WT.mc_id=academic-105485-koreyst) के प्रैक्टिशनर्स द्वारा अनुशंसित हैं।

| क्या                                  | क्यों                                                                                                                                                                                                                                               |
| :------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| नवीनतम मॉडलों का मूल्यांकन करें।    | नए मॉडल पीढ़ियों में बेहतर विशेषताएं और गुणवत्ता होने की संभावना है - लेकिन वे उच्च लागत भी उठा सकते हैं। उनके प्रभाव का मूल्यांकन करें, फिर माइग्रेशन निर्णय लें।                                                                                |
| निर्देश और संदर्भ को अलग करें।       | जांचें कि क्या आपका मॉडल/प्रदाता _डेलिमिटर_ परिभाषित करता है ताकि निर्देशों, प्राथमिक और माध्यमिक सामग्री को अधिक स्पष्ट रूप से अलग किया जा सके। इससे मॉडल को टोकन को अधिक सटीकता से वज़न देने में मदद मिल सकती है।                                                         |
| विशिष्ट और स्पष्ट रहें।               | वांछित संदर्भ, परिणाम, लंबाई, फॉर्मेट, शैली आदि के बारे में अधिक विवरण दें। इससे प्रतिक्रियाओं की गुणवत्ता और स्थिरता दोनों में सुधार होगा। पुन: प्रयोज्य टेम्पलेट्स में रेसिपी कैप्चर करें।                                                          |
| वर्णनात्मक रहें, उदाहरण का उपयोग करें।| मॉडल "दिखाओ और बताओ" दृष्टिकोण के लिए बेहतर प्रतिक्रिया दे सकते हैं। `zero-shot` approach where you give it an instruction (but no examples) then try `few-shot` as a refinement, providing a few examples of the desired output. Use analogies. |
| Use cues to jumpstart completions | Nudge it towards a desired outcome by giving it some leading words or phrases that it can use as a starting point for the response.                                                                                                               |
| Double Down                       | Sometimes you may need to repeat yourself to the model. Give instructions before and after your primary content, use an instruction and a cue, etc. Iterate & validate to see what works.                                                         |
| Order Matters                     | The order in which you present information to the model may impact the output, even in the learning examples, thanks to recency bias. Try different options to see what works best.                                                               |
| Give the model an “out”           | Give the model a _fallback_ completion response it can provide if it cannot complete the task for any reason. This can reduce chances of models generating false or fabricated responses.                                                         |
|                                   |                                                                                                                                                                                                                                                   |

As with any best practice, remember that _your mileage may vary_ based on the model, the task and the domain. Use these as a starting point, and iterate to find what works best for you. Constantly re-evaluate your prompt engineering process as new models and tools become available, with a focus on process scalability and response quality.

<!--
LESSON TEMPLATE:
This unit should provide a code challenge if applicable

CHALLENGE:
Link to a Jupyter Notebook with only the code comments in the instructions (code sections are empty).

SOLUTION:
Link to a copy of that Notebook with the prompts filled in and run, showing what one example could be.
-->

## Assignment

Congratulations! You made it to the end of the lesson! It's time to put some of those concepts and techniques to the test with real examples!

For our assignment, we'll be using a Jupyter Notebook with exercises you can complete interactively. You can also extend the Notebook with your own Markdown and Code cells to explore ideas and techniques on your own.

### To get started, fork the repo, then

- (Recommended) Launch GitHub Codespaces
- (Alternatively) Clone the repo to your local device and use it with Docker Desktop
- (Alternatively) Open the Notebook with your preferred Notebook runtime environment.

### Next, configure your environment variables

- Copy the `.env.copy` file in repo root to `.env` and fill in the `AZURE_OPENAI_API_KEY`, `AZURE_OPENAI_ENDPOINT` and `AZURE_OPENAI_DEPLOYMENT` मूल्यों के साथ शुरू करें। [लर्निंग सैंडबॉक्स सेक्शन](../../../04-prompt-engineering-fundamentals/04-prompt-engineering-fundamentals) पर वापस जाएं ताकि यह सीख सकें कि कैसे।

### अब, Jupyter Notebook खोलें

- रनटाइम कर्नेल का चयन करें। यदि विकल्प 1 या 2 का उपयोग कर रहे हैं, तो बस डिफ़ॉल्ट Python 3.10.x कर्नेल का चयन करें जो डेवलपमेंट कंटेनर द्वारा प्रदान किया गया है।

आप अभ्यास चलाने के लिए तैयार हैं। ध्यान दें कि यहाँ _सही और गलत_ उत्तर नहीं हैं - बस विकल्पों का परीक्षण करके और यह समझकर कि दिए गए मॉडल और एप्लिकेशन डोमेन के लिए क्या काम करता है।

_इस कारण से इस पाठ में कोई कोड समाधान खंड नहीं हैं। इसके बजाय, नोटबुक में "माई सॉल्यूशन:" शीर्षक वाले मार्कडाउन सेल होंगे जो संदर्भ के लिए एक उदाहरण आउटपुट दिखाते हैं।_

## ज्ञान की जांच

निम्नलिखित में से कौन सा कुछ उचित सर्वोत्तम प्रथाओं का पालन करने वाला एक अच्छा प्रॉम्प्ट है?

1. मुझे एक लाल कार की छवि दिखाओ
2. मुझे एक लाल कार की छवि दिखाओ जिसका निर्माण वोल्वो है और मॉडल XC90 है, जो एक चट्टान के पास खड़ी है और सूर्यास्त हो रहा है
3. मुझे एक लाल कार की छवि दिखाओ जिसका निर्माण वोल्वो है और मॉडल XC90 है

A: 2, यह सबसे अच्छा प्रॉम्प्ट है क्योंकि यह "क्या" के बारे में विवरण प्रदान करता है और विशेषताओं में जाता है (सिर्फ कोई कार नहीं बल्कि एक विशिष्ट निर्माण और मॉडल) और यह समग्र सेटिंग का भी वर्णन करता है। 3 अगला सबसे अच्छा है क्योंकि इसमें भी बहुत विवरण है।

## 🚀 चुनौती

देखें कि क्या आप "संकेत" तकनीक का उपयोग कर सकते हैं प्रॉम्प्ट के साथ: वाक्य को पूरा करें "मुझे एक लाल कार की छवि दिखाओ जिसका निर्माण वोल्वो है और "। यह किसके साथ प्रतिक्रिया करता है, और आप इसे कैसे सुधारेंगे?

## शानदार काम! अपनी सीख जारी रखें

क्या आप विभिन्न प्रॉम्प्ट इंजीनियरिंग अवधारणाओं के बारे में और अधिक सीखना चाहते हैं? इस विषय पर अन्य महान संसाधनों को खोजने के लिए [जारी शिक्षा पृष्ठ](https://aka.ms/genai-collection?WT.mc_id=academic-105485-koreyst) पर जाएं।

पाठ 5 पर जाएं जहां हम [उन्नत प्रॉम्प्टिंग तकनीकों](../05-advanced-prompts/README.md?WT.mc_id=academic-105485-koreyst) को देखेंगे!

**अस्वीकरण**:  
यह दस्तावेज़ AI अनुवाद सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया अवगत रहें कि स्वचालित अनुवादों में त्रुटियाँ या अशुद्धियाँ हो सकती हैं। अपनी मूल भाषा में मूल दस्तावेज़ को आधिकारिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम जिम्मेदार नहीं हैं।